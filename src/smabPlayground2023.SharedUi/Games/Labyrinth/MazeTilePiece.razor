<div data-treasure="@(MazeTile.Treasure is not Treasure.None ? MazeTile.Treasure : null)"
	 data-directions="@MazeTile.PathDirections()"
	 data-playerhome="@MazeTile.Treasure.IsPlayer()"
	 data-rotation="@MazeTile.Orientation"
	 @onclick="async () => { await OnClick.InvokeAsync(); }"
	 @oncontextmenu="async () => { await OnContextMenu.InvokeAsync(); }"
	 @oncontextmenu:preventDefault="@Extra"
	 @attributes="AdditionalAttributes">
	 @if (MazeTile.NorthExit) { <i class="bi bi-arrow-up" aria-hidden="true" data-direction="N" /> }
	 @if (MazeTile.WestExit)  { <i class="bi bi-arrow-left" aria-hidden="true" data-direction="W" /> }
	 @if (MazeTile.EastExit)  { <i class="bi bi-arrow-right" aria-hidden="true" data-direction="E" /> }
	 @if (MazeTile.SouthExit) { <i class="bi bi-arrow-down" aria-hidden="true" data-direction="S" /> }
	<span class="emoji">@((MarkupString)FormatTreasure(MazeTile.Treasure))</span>
</div>

@code {
	[Parameter, EditorRequired]
	public required MazeTile MazeTile { get; set; }

	[Parameter]
	public bool Extra { get; set; } = false;

	[Parameter]
	public FormatTreasure FormatTreasure { get; set; } = FormatTreasureDefaults.DefaultEmoji;

	[Parameter(CaptureUnmatchedValues = true)]
	public Dictionary<string, object>? AdditionalAttributes { get; set; }

	[Parameter] public EventCallback OnClick { get; set; }
	[Parameter] public EventCallback OnContextMenu { get; set; }
}
