@page "/games/boggle"
@page "/games/boggle/{boggleType}"
@rendermode InteractiveServer
@inject DictionaryOfWords _dictionary;
@implements IDisposable

<SmabPageTitle>@boggleFriendlyName</SmabPageTitle>
<div class="row">
	<button class="btn btn-primary" type="button" @onclick="() => StartNewGame()">New Game</button>
</div>
@if (boggleDice is not null) {
	<div>
		<div id="board_container">
			<div>
				<div id="board" @oncontextmenu:preventDefault>
					@for (int r = 0; r < boggleDice.BoardHeight; r++) {
						@for (int c = 0; c < boggleDice.BoardWidth; c++) {
							int row = r;
							int col = c;
							PositionedDie positionedDie = boggleDice.Board.Where(d => d.Row == row && d.Col == col).Single();
							<BoggleDie
								Die                   = "@((LetterDie?)(positionedDie.Die))"
								IsSelected            = "@boggleSlots[(col, row)].IsSelected"
								ArrowDirection        = "@boggleSlots[(col, row)].ArrowDirection"
								OnClickCallback       = "() => OnBoardClick(positionedDie, col, row)"
								OnContextMenuCallback = "() => OnBoardClick(positionedDie, col, row, isEnd: true)" />
						}}
				</div>
				@if (boggleDice.HasDictionary) {
					<div id="dictionary"><span>with dictionary</span></div>
				}
			</div>
		</div>
		<BoggleWordList Score="boggleDice.Score" WordScores="boggleDice.WordScores" TimeRemaining="new TimeSpan(0, 3, 0)" />
	</div>
	<style>
		#board {
			--board-width:  @boggleDice.BoardWidth;
			--board-height: @boggleDice.BoardHeight;
		}
	</style>
}


@code {
	[Parameter] public string boggleType { get; set; } = "deluxe";

	public BoggleDice.BoggleType BoggleSetType { get; set; } = BoggleDice.BoggleType.Classic4x4;
	private string boggleFriendlyName => BoggleSetType switch
		{
			BoggleDice.BoggleType.Classic4x4         => "Boggle Classic",
			BoggleDice.BoggleType.BigBoggleDeluxe    => "Big Boggle Deluxe",
			BoggleDice.BoggleType.SuperBigBoggle2012 => "Super Big Boggle",
			BoggleDice.BoggleType.New4x4             => "New Boggle 4x4",
			BoggleDice.BoggleType.BigBoggleOriginal  => "Big Boggle",
			BoggleDice.BoggleType.BigBoggleChallenge => "Big Boggle Challenge",
			_ => "Boggle"
		};

	public bool CancelTimer { get; set; } = false;

	private BoggleDice boggleDice = null!;
	private Dictionary<(int, int), BoggleSlot> boggleSlots = new();

	private Stack<BoggleSlot> previousSlots = [];
	private string? currentWord = "";

	protected override void OnParametersSet()
	{
		BoggleSetType = boggleType?.ToLowerInvariant() switch
		{
			"classic"     => BoggleDice.BoggleType.Classic4x4,
			"deluxe"      => BoggleDice.BoggleType.BigBoggleDeluxe,
			"superbig"    => BoggleDice.BoggleType.SuperBigBoggle2012,
			"new"         => BoggleDice.BoggleType.New4x4,
			"bigoriginal" => BoggleDice.BoggleType.BigBoggleOriginal,
			"challenge"   => BoggleDice.BoggleType.BigBoggleChallenge,
			_ => BoggleDice.BoggleType.Classic4x4
		};
	}

	void StartNewGame()
	{
		boggleDice = new(BoggleSetType, _dictionary);
		boggleSlots = boggleDice.Board.ToDictionary(
			d => (d.Col, d.Row),
			d => new BoggleSlot(d.Col, d.Row, (LetterDie)(d.Die))
		);
	}

	private void OnBoardClick(PositionedDie positionedDie, int col, int row, bool isEnd = false)
	{
		LetterDie die = ((LetterDie)(positionedDie.Die));
		string letter = die.FaceValue.Value ?? "";
		(int Col, int Row) position = (col, row);
		BoggleSlot slot = boggleSlots[position];
		BoggleSlot? prevSlot = previousSlots.Count > 0 ? previousSlots.Peek() : null;
		if (isEnd) {
			if (currentWord is not null && prevSlot is not null) {
				BoggleDice.WordScore wordScore = boggleDice.PlayWord(currentWord);
				// Console.WriteLine($"Word:  {currentWord}  Score: {wordScore.Score} Reason: {wordScore.Reason}");
			}
			currentWord = "";
			previousSlots = [];
			foreach (((int c, int r) pos, BoggleSlot boggleSlot) in boggleSlots.Where(kvp => kvp.Value.IsSelected = true)) {
				boggleSlots[pos] = (boggleSlots[pos] with { IsSelected = false }).SetNoArrowDirection();
				boggleSlots[pos].SetNoArrowDirection();
			}
		} else if (slot.IsSelectable && (prevSlot is null || prevSlot.IsAdjacent(slot.Col, slot.Row))) {
			// Console.WriteLine($"Selected: {letter} at ({slot.Col}, {slot.Row})");
			if (prevSlot is null) {
				boggleSlots[position].SetArrowDirection(prevSlot?.Col, prevSlot?.Row, slot.Col, slot.Row);
			} else {
				boggleSlots[(prevSlot.Col, prevSlot.Row)].SetArrowDirection(prevSlot?.Col, prevSlot?.Row, slot.Col, slot.Row);
			}
			boggleSlots[position].IsSelected = true;
			currentWord += letter;
			previousSlots.Push(boggleSlots[position]);
		} else if (prevSlot?.Col == slot.Col && prevSlot?.Row == slot.Row) {
			// ToDo - rewrite "prev" logic to use a stack so we can undo properly
			slot.IsSelected = false;
			currentWord = currentWord?[..^(letter.Length)];
			_ = previousSlots.Pop();
			prevSlot = previousSlots.Count > 0 ? previousSlots.Peek() : null;
			if (prevSlot is null) {
				boggleSlots[position].SetArrowDirection(prevSlot?.Col, prevSlot?.Row, slot.Col, slot.Row);
			} else {
				boggleSlots[(prevSlot.Col, prevSlot.Row)].SetNoArrowDirection();
			}

		}
	}

	public void Dispose()
	{
		CancelTimer = true;
	}

	public record class BoggleSlot(int Col, int Row, LetterDie Die)
	{
		public static string NoArrowDirection = "NONE";
		public string ArrowDirection { get; set; } = NoArrowDirection;

		public bool IsSelected { get; set; } = false;
		public bool IsSelectable => (Die?.FaceValue.Value != "#" && !IsSelected);

		public bool IsAdjacent(int col, int row)
		{
			int dCol = int.Abs(Col - col);
			int dRow = int.Abs(Row - row);
			return (dCol is 0 or 1) && (dRow is 0 or 1);
		}

		public BoggleSlot SetNoArrowDirection() {
			ArrowDirection = NoArrowDirection;
			return this;
		}

		public BoggleSlot SetArrowDirection(int? prevCol, int? prevRow, int newCol, int newRow)
		{
			if (prevCol is null || prevRow is null) {
				ArrowDirection = "START";
			} else {
				ArrowDirection = (newCol - prevCol, newRow - prevRow) switch
				{
					( 0,  0) => "END",
					( 0, -1) => "N",
					( 1,  0) => "E",
					( 0,  1) => "S",
					(-1,  0) => "W",
					( 1, -1) => "NE",
					( 1,  1) => "SE",
					(-1,  1) => "SW",
					(-1, -1) => "NW",
					_ => ""
				};
			} 

			return this;
		}
	}
}
